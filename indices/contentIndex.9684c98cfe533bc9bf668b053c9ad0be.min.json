{"/":{"title":"WongSSH Knowledge","content":"\n你好，欢迎来到我的个人知识库，此知识库建立在[Quartz](https://github.com/jackyzha0/quartz) 框架上，最大的特点是支持类似[obsidian](https://obsidian.md/)的双链笔记形式，您可以在每篇文章的底部找到对应的双链关系和对应的联系图。\n\n与我的[个人博客](https://hugo.wongssh.cf) 不同，本文内的所有文章都具有原子性，即每篇文章尽可能实现高内聚，仅专注于某一部分内容，而大量的拓展内容均采用外链的形式给出。但本网站的一大缺陷在于知识之间的实际联系较弱，读者只能理解各知识之间的理论联系，而很难分析出其在实际联系，而此本份主要由我的个人博客给出。\n\n与一般的双链笔记不同，本网站致力于实现各篇内容的联系的格式化。基于此目的，本网站采用了计算机科学中最常见的树结构编排主逻辑，读者可以自本篇开始遍历所以可见节点。在节点层级上，越容易进入的节点内容抽象程度最高，读者可以再次节点内给出的其他链接遍历以获得更底层的知识。本网站尽可能保证使高中以上学历的读者可以理解最底层的节点内容。\n\n根节点列表:\n\n- [密码学](crypto/root.md)\n","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/DES":{"title":"DES","content":"\n\u003e [!warning]\n\u003e  `DES`算法在目前已经不具有安全性，我们可以使用硬件快速爆破`DES`密钥。且`DES`在加密效率上只有高效的硬件实现而没有高效的软件实现，不推荐在现代基础设施上使用此加密算法。\n\n本页面主要介绍`DES`算法，`DES`是一种使用 56 位密钥(实际上，我们一般看到 64 位的密钥中有 8 位校验位无法参与加密)对 64 位长分组进行加密的密码。\n\n## 加密\n\n其具体加密给出的流程图如下:\n\n![DES Flow](https://img.gejiba.com/images/faed068123175795e20491afa18d9bb8.png)\n\n上述步骤可用文字表述如下:\n1. 明文被分解成以 64 bit 为一组的数据 \n2. 将 64 bit 为一组的明文 $x$ 使用 [[crypto/concept/初始置换与逆置换|初始置换]] $IP(x)$ 进行处理\n3. 将置换后的结果分为左右两部分，每一部分长度为 32 bit，分别记为$L_0$、$R_0$\n4. 将右侧 $L_0$ 部分(32 bit) 与经过 [[crypto/concept/密钥编排|密钥编排]](`Key schedule`) 后的 48 bit 密钥输入 f 函数\n5. 将 [[crypto/concept/F函数|f函数]] 输出结果与左侧$R_0$进行异或获得的结果记为$R_1$\n6. 将原有输入 $R_0$ 直接记为 $L_1$\n\n我们将上述 3 - 6 步流程重复 16 轮，最后获得结果进行 [[crypto/concept/初始置换与逆置换|初始逆置换]]输出密文。\n\n上述结构被称为`Feistel 网络`，其数学表达形式如下:\n$$L_i = R_{i-1} $$\n$$R_i = L_{i-1} \\oplus f(R_{i-1}, k_i)$$\n\n其中，各参数的含义均可以在`Ferstel 网络`的结构图中获得。\n\n我们可以认为在`DES`加密流程内，我们使用右侧数据、密钥和 [[crypto/concept/F函数|f函数]] 构造了一个随机数生成器以加密左侧。\n\n## 解密\n\n解密的流程图如下：\n\n![DES decrypt](https://img.gejiba.com/images/16f368123ea7fb6a7d6e1879ccf0d551.png)\n\n与加密相比，在解密中，我们逆转了[[crypto/concept/密钥编排|密钥编排]]部分。正如我们在密钥编排内提到的结论，即：\n$$C_0 = C_{16}$$\n$$D_0 = D_{16}$$\n基于上述结论，我们可以得到加密过程中使用的 $k_{16}$ 密钥，获得此密钥后我们可以正确解密第 16 轮加密。同时，我们可以通过在解密过程中使用向右移位的 $RS_i$  替代加密过程中向左移位的 $LS_i$  获得正确的 $k_{15}$ 等密钥。\n\n\u003e 向左移位与向右移位显然属于逆操作\n\n总体来说，密钥编排流程图如下：\n\n![DES Decrypt Key Schedule](https://img.gejiba.com/images/716c31a22c6b194c99b74f7c22bee0b4.png)\n\n## 数学推导\n\n假如我们获得明文 $x$ ,加密过程如下:\n\n$$\n\\begin{align}\n\tL_0, R_0 \u0026= IP(x)\\\\\n\tL_1, R_1 \u0026= f(R_0, k_1), R_0\\\\\n\tL_i, R_i \u0026= f(R_{i-1}, k_i), L_{i-1}\\\\\n\tL_{15}, R_{15} \u0026= f(R_{14}, k_{15}), L_{14}\\\\\n\tY \u0026= IP^{-1}(L_{15} || R_{15})\n\\end{align}\n$$\n其中，\n\t$f$ 即代表上文出现的 [[crypto/concept/F函数|f函数]] \n\t$\\|$ 代表数据拼接\n\t\n解密过程如下：\n\n\n接下来，我们给出一个完整的数学推导过程证明解密的正确性，如下:\n\n$$(L_0^d, R_0^d) = IP(IP^{-1}(R_{16}, L_{16})) = (R_{16}, L_{16})$$\n我们输入在解密函数经过$IP(x)$函数的 $(L_0^d, R_0^d)$ 实质上与加密函数最后一轮","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2%E4%B8%8E%E9%80%86%E7%BD%AE%E6%8D%A2":{"title":"初始置换与逆置换","content":"\nIP置换 $IP(x)$ 与 IP逆置换 $IP^{-1}(x)$ 用于 [DES](/crypto/DES.md) 的明文处理的第一步和密文处理的最后一步。\n\n此过程只是简单的数据位交换，对于[DES](/crypto/DES.md) 的安全性并没有提高。\n\n其过程可以使用下图简单的进行表示：\n\n![IP pic](https://img.gejiba.com/images/f85131bcb32e980acef55fa528725200.png)\n\n下表给出了初始置换 $IP$ 的映射表格：\n|    |    |    |    |    |    |    |    |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| 58 | 50 | 42 | 34 | 26 | 18 | 10 | 2 |\n| 60 | 52 | 44 | 36 | 28 | 20 | 12 | 4 |\n| 62 | 54 | 46 | 38 | 30 | 22 | 14 | 6 |\n| 64 | 56 | 48 | 40 | 32 | 24 | 16 | 8 |\n| 57 | 49 | 41 | 33 | 25 | 17 | 9  | 1 |\n| 59 | 51 | 43 | 35 | 27 | 19 | 11 | 3 |\n| 61 | 53 | 45 | 37 | 29 | 21 | 13 | 5 |\n| 63 | 55 | 47 | 39 | 31 | 23 | 15 | 7 |\n\n 此映射表格从左至右、从上至下，依次表示每一个位对于的置换后的位置。假如我们需要置换第  10 位，我们可以简单的数表格，得到第 10 位应当置换到第 52 位。\n\n下表展示了 $IP^{-1}$ 的映射表格，其与上文给出的初始置换表格的置换完全相反。\n\n| ||||||||\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n|40|8|48|16|56|24|64|32|\n|39|7|47|15|55|23|63|31|\n|38|6|46|14|54|22|62|30|\n|37|5|45|13|53|21|61|29|\n|36|4|44|12|52|20|60|28|\n|35|3|43|11|51|19|59|27|\n|34|2|42|10|50|18|58|26|\n|33|1|41|9|49|17|57|25| \n\n上述置换在软件实现上具有一定的复杂性，但在硬件实现上较为简单。由于[DES](crypto/DES.md) 的设计具有相当的黑箱性质，关于此置换存在的原因，我们不得而知，可能是为了更好的数据读取。","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/%E5%AF%86%E9%92%A5%E7%BC%96%E6%8E%92":{"title":"密钥编排","content":"\n密钥编排接受 64 bit 长度的密钥（实际长度为 56 bit ）将其生成 16 轮加密流程中使用的 48 bit 密钥。结构图如下：\n\n![Key Struct](https://img.gejiba.com/images/b95a0a7d704430e74805f2562756c701.png)\n\n我们首先使用 `PC-1` 去除校验位并进行密码重排，使用的表格如下：\n\n![PC-1 Table](https://img.gejiba.com/images/52fecb8d9d0abd016c7f7a7edc3136bb.png)\n\n将获得的 56 bit 的输出分为 $C_0$ 和 $D_0$ 部分，接下来我们使用$LS_i$函数进行移位操作，具体规定如下：\n\n1. 当 $i = 1, 2, 9, 16$时，$LS_i$表达向左移动 1 位\n2. 当 $i \\not = 1, 2, 9, 16$时，$LS_i$表示向左移动 2 位\n\n简单计算左移位数 $4*1 + 12 * 2 = 28$ ，恰好为 $C_i$ 或 $D_i$ 的位数。这带了一个极其有用的特性，即$C_0 = C_{16}$ 和 $D_0 = D_{16}$ ，这对于[[crypto/DES#解密|解密]]密钥编排非常有用。\n\n最终，我们将生成的 $L_i$ 和 $D_i$ 拼接起来，并根据`PC-2`表格进行替换，表格如下：\n\n![PC-2 Table](https://img.gejiba.com/images/ff7e639951e23e17b48e0bc4da3148ce.png)\n\n由此，我们可以得到第 $i$ 轮所需要的密钥","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/%E6%B7%B7%E6%B7%86%E4%B8%8E%E6%89%A9%E6%95%A3":{"title":"混淆与扩散","content":"\n## 混淆（Confusion）\n\n此操作是一种使密钥盒密文之间关系尽可能模糊的加密操作，最常用的方法是替换\n\n## 扩散（Diffusion）\n\n是一种为了隐藏明文的统计属性而将一个明文符号的影响扩散到多个密文符号的加密操作，最常用的方法是置换\n\n","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/%E7%BD%AE%E6%8D%A2P":{"title":"置换P","content":"\n置换P 的作用是将 8 个 [[crypto/concept/S-盒|S-盒]] 内的数据进行置换，将[[crypto/concept/混淆与扩散#扩散（Diffusion）|扩散]]引入`DES`加密。\n\n置换P 仍旧采用了简单的表格，如下：\n\n![P Table](https://img.gejiba.com/images/1254868b147ef9d11ddf45db57881232.png)\n","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/E%E7%BD%AE%E6%8D%A2":{"title":"扩展置换E","content":"\n$E(R_{i-1})$ 拓展置换的目的是将 32 bit 的 $R_{i-1}$输入扩展为 48 bit\n\n置换的示意图如下：\n\n![E Chart](https://img.gejiba.com/images/c353f2c77c64ffb8e5c66e9161d218ea.png)\n\n完整的置换表格可以参考下表：\n\n![E Table](https://acjgpfqbqr.cloudimg.io/_cat_/ncdf1m.jpg)\n\n通过表格，我们可以发现我们复用了32、4、8、12、16、20、24、28、5、9、13、17、21、25、29、1位的数据，共计 16 位，实现了 32 bit 到 48 bit 的扩展置换。","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/F%E5%87%BD%E6%95%B0":{"title":"F函数","content":"\nf函数的处理流程图如下：\n\n![F function](https://img.gejiba.com/images/9b61d89173644a8f48be626c3a881165.png)\n\n其中，参数含义为：\n\t$R_{i-1}$ 上一轮加密获得的右半部分 32 bit\n\t$k_i$ [[crypto/concept/密钥编排|密钥编排]]获得的 48 bit 密钥\n\n当获得 32 bit 的 $R_{i-1}$ 时，我们发现长度显然与 $k_i$ 的长度不符，所以我们需要拓展 $R_{i-1}$ ，故而使用了$E(R_{i-1})$ [[crypto/concept/E置换|扩展置换]]。\n\n将扩展置换后的结果与[[crypto/concept/密钥编排|密钥编排]]后的$k_i$进行异或(XOR)操作，获得 48 bit 输出。我们将输出以 6 bit 为一组推入 [[crypto/concept/S-盒|S-盒]] 获得 32 bit 输出。\n\n最后，我们将 [[crypto/concept/S-盒|S-盒]] 的输出汇总后输入 [[crypto/concept/置换P|置换P]]  获得最终 32 bit 输出。","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/concept/S-%E7%9B%92":{"title":"S-盒","content":"\n在[[crypto/concept/F函数|F函数]]结构图内，我们发现 S盒 具有特定的编号，原因是每一个 S盒 都有特定的查找表，此表将 6 bit 的输入转换为 4 bit 的输出。\n\n一个简单的查找示例如下:\n\n假如我们需要将第一分组内的`110010`数据输入 S-盒，根据规则，此数据应由$s_1$盒进行处理，我们首先选择此数据的最高位和最低位构成`10`，计算此数据等于`2`，我们需要查询 $s_1$ 盒内的第 2 行，接下来，我们计算其他位的数据`1001`，计算结果为`9`，则查询$s_1$表格内的第 9 列，最终获得结果。\n\n整体过程，可通过下图理解：\n\n![S Box](https://img.gejiba.com/images/b586f43ca9d6a3b70195f0c7da971c86.png)\n\n\u003e [!example]\n\u003e \n\u003e  假如推入 $s_1$ 盒的数据为`100101` ，请读者自行查询其输出值\n\u003e  \n\u003e  正确结果应该为 `1000`\n\n完整的 S-盒 表格，读者可自行前往[维基百科](https://en.wikipedia.org/wiki/DES_supplementary_material#Substitution_boxes_(S-boxes))查询。\n\n\u003e [!info]\n\u003e \n\u003e S-盒 的设计思路是不明确的，所以很多人认为NSA可能在其中设计了秘密后门。\n\u003e 但 S-盒 可以帮助 DES 阻挡很多高级数学攻击，比如差分密码分析等\n\u003e S-盒 也引入了重要的非线性的特性，即：\n\u003e $$S(a) \\oplus S(b) \\not = S(a \\oplus b)$$\n\n","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null},"/crypto/root":{"title":"密码学根节点","content":"\n本文为密码学根节点，包含以下内容:\n\n- [[crypto/DES|DES]]\n- AES\n- RSA\n\n本节点在写作过程中，主要参考了以下书目:\n\n1. 《深入浅出密码学》\n1. 《图解密码学技术》","lastmodified":"2022-10-07T15:56:31.649937748Z","tags":null}}